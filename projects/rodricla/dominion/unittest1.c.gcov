        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdlib.h>
        -:    5:#include <stdio.h>
        -:    6:void rv_shuffle_deckCount(int rv, int rp);
        -:    7:int check_shuffle(int player, struct gameState *one, struct gameState *two);
function main called 1 returned 100% blocks executed 95%
        1:    8:int main(int argc, char *argv[]) 
        -:    9:{
        1:   10:	printf("-------UNIT TEST 1------\n");
call    0 returned 100%
        1:   11:	printf("---Testing 'shuffle'---\n");
call    0 returned 100%
        1:   12:	struct gameState* testShuffle=newGame();
call    0 returned 100%
        1:   13:	struct gameState* save=newGame();
call    0 returned 100%
        1:   14:	int numPlayers=2;
        1:   15:	int* kc=kingdomCards(adventurer, baron, council_room, feast, gardens, remodel, smithy, village, great_hall, minion);
call    0 returned 100%
        1:   16:	int randomSeed=1000;
        1:   17:	initializeGame(numPlayers, kc, randomSeed, testShuffle);
call    0 returned 100%
        -:   18:	//return value=rv
        1:   19:	int rv=0;
        -:   20:	//save the state
        1:   21:	*save=*testShuffle;
        1:   22:	int rp=whoseTurn(testShuffle);
call    0 returned 100%
        -:   23:	//assume that all hands are now in deck array or hand or played and that the discard pile is empty
        1:   24:	printf("PRE-CONDITIONS: FOR TEST CASE 1:\n1.`shuffle()` is receiving an empty discard pile for player %i:\n ", rp);
call    0 returned 100%
        1:   25:	printf("testShuffle->discardCount[%i]:%i\n", rp, testShuffle->discardCount[rp]);
call    0 returned 100%
        -:   26:	
        1:   27:	rv=shuffle(rp, testShuffle);
call    0 returned 100%
        1:   28:	if (rv==0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   29:	{
        1:   30:		printf("shuffle returned 0, indicating success; checkign deck\n");
call    0 returned 100%
        1:   31:		if (check_shuffle(rp, save, testShuffle)>0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   32:		{
    #####:   33:			printf("OVERALL: Success, at least one item changed in deck\n");
call    0 never executed
        -:   34:		}
        -:   35:		else 
        -:   36:		{
        1:   37:			printf("OVERALL: Failure, not even one item changed in deck\n");
call    0 returned 100%
        -:   38:		}
        -:   39:	}
        -:   40:	
        -:   41:
        -:   42:	
        1:   43:	printf("\n\nPRE-CONDITIONS: FOR TEST CASE 2: Empty player deck for player %i.\nShuffle checks the state of the players deck; if it is less than  1, it should return -1\n", rp);
call    0 returned 100%
        1:   44:	*testShuffle=*save;
        1:   45:	testShuffle->deckCount[rp]=0;
        1:   46:	rv=shuffle(rp, testShuffle);
call    0 returned 100%
        -:   47:	
        1:   48:	rv_shuffle_deckCount(rv, rp);
call    0 returned 100%
        -:   49:	//after running rv_shuffle_deckCount with -1 and some rp, running the followign statement would give us 100% coverage for the rv_shuffle_deckount branches, but I don't know how to trick "shuffled" into ignoring an empty deck.
        -:   50:	//rv_shuffle_deckCount(0, rp);
        -:   51:	
        1:   52:	printf("-------FINISHED UNIT TEST 1------\n");
call    0 returned 100%
        1:   53:	return 0;
        -:   54:	
        -:   55:}
function rv_shuffle_deckCount called 1 returned 100% blocks executed 60%
        1:   56:void rv_shuffle_deckCount(int rv, int rp)
        -:   57:{
        1:   58:	if (rv==-1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   59:	{
        1:   60:		printf("SUCCESS: noted that the deckCount for player %i is less than one\n", rp);
call    0 returned 100%
        -:   61:	}
    #####:   62:	else if (rv!=-1)
branch  0 never executed
branch  1 never executed
        -:   63:	{
    #####:   64:		printf("FAILURE: did not note that the deckCount for player %i is less than one, returned %i\n", rp, rv);
call    0 never executed
        -:   65:	}
        1:   66:}
function check_shuffle called 1 returned 100% blocks executed 80%
        1:   67:int check_shuffle(int player, struct gameState *one, struct gameState *two)
        -:   68:{
        1:   69:	int n=one->deckCount[player];
        -:   70:	int i;
        1:   71:	int failureCount=0;
        1:   72:	int successCount=0;
        6:   73:	for (i=0; i < n; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:   74:	{
        5:   75:		if (one->deck[player][i]==two->deck[player][i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   76:		{ 
        5:   77:			printf("FAILURE: card for player %i at %i the same as before: %i and %i\n", player,  i, one->deck[player][i], two->deck[player][i]);
call    0 returned 100%
        5:   78:			failureCount++;
        -:   79:		}
        -:   80:		else 
        -:   81:		{
    #####:   82:			printf("SUCCESS: card for player %i at %i NOT the same as before: %i and %i\n", player,  i, one->deck[player][i], two->deck[player][i]);
call    0 never executed
    #####:   83:			successCount++;
        -:   84:		}
        -:   85:	}
        1:   86:	return successCount;
        -:   87:}
        -:   88:/*
        -:   89:int shuffle(int player, struct gameState *state) {
        -:   90: 
        -:   91:
        -:   92:	int newDeck[MAX_DECK];
        -:   93:	int newDeckPos = 0;
        -:   94:	int card;
        -:   95:	int i;
        -:   96:
        -:   97:	if (state->deckCount[player] < 1)
        -:   98:		return -1;
        -:   99:	qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  100:	//SORT CARDS IN DECK TO ENSURE DETERMINISM!
        -:  101:
        -:  102:	while (state->deckCount[player] > 0) {
        -:  103:		card = floor(Random() * state->deckCount[player]);
        -:  104:		newDeck[newDeckPos] = state->deck[player][card];
        -:  105:		newDeckPos++;
        -:  106:		for (i = card; i < state->deckCount[player]-1; i++) {
        -:  107:			state->deck[player][i] = state->deck[player][i+1];
        -:  108:		}
        -:  109:		state->deckCount[player]--;
        -:  110:	}
        -:  111:	for (i = 0; i < newDeckPos; i++) {
        -:  112:		state->deck[player][i] = newDeck[i];
        -:  113:		state->deckCount[player]++;
        -:  114:	}
        -:  115:
        -:  116:	return 0;
        -:  117:}
        -:  118:
        -:  119:*/
